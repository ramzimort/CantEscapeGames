\hypertarget{structPool_1_1PoolPage}{}\section{Pool$<$ T $>$\+:\+:Pool\+Page Struct Reference}
\label{structPool_1_1PoolPage}\index{Pool$<$ T $>$\+::\+Pool\+Page@{Pool$<$ T $>$\+::\+Pool\+Page}}


Allocates and initializes linked list of poolitems (as pointers) based on page size Contains unique pointer to array of Poolitems Contains unique poninter to next pool as well. When unique pointers go out of scope, all allocated memory is destroyed.  




{\ttfamily \#include $<$Pool\+Allocator.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{structPool_1_1PoolPage_afef7a665383a998fa091ece35d47a190}\label{structPool_1_1PoolPage_afef7a665383a998fa091ece35d47a190}} 
{\bfseries Pool\+Page} (size\+\_\+t n)
\item 
\mbox{\Hypertarget{structPool_1_1PoolPage_a9bc982e7b299e40a5b4f72e51c40cbe2}\label{structPool_1_1PoolPage_a9bc982e7b299e40a5b4f72e51c40cbe2}} 
\hyperlink{unionPool_1_1PoolItem}{Pool\+Item} $\ast$ {\bfseries Get\+Storage} () const
\item 
\mbox{\Hypertarget{structPool_1_1PoolPage_aa1c17dc8da628fbf765fbd0ebcc6e26b}\label{structPool_1_1PoolPage_aa1c17dc8da628fbf765fbd0ebcc6e26b}} 
void {\bfseries Set\+Next\+Page} (std\+::unique\+\_\+ptr$<$ \hyperlink{structPool_1_1PoolPage}{Pool\+Page} $>$ \&\&n)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
struct Pool$<$ T $>$\+::\+Pool\+Page}

Allocates and initializes linked list of poolitems (as pointers) based on page size Contains unique pointer to array of Poolitems Contains unique poninter to next pool as well. When unique pointers go out of scope, all allocated memory is destroyed. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Memory/\hyperlink{PoolAllocator_8h}{Pool\+Allocator.\+h}\end{DoxyCompactItemize}
